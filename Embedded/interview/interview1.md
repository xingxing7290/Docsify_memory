# 嵌入式面试

## **第一类问题：专业考察题**

在下面问题中，我附上自己的理解，可能不全面，用到的话再自行补充一些。

**问题 1：问你写在简历上的项目经历，一般问的很细很细，在此基础上考察你项目里用到的技术知识。**

**问题 2：IIC 协议**

（1）I2C 使用两条线在主控制器和从机之间进行数据通信。一条是  SCL(串行时钟线)，另外一条是 SDA(串行数据线)，

（2）这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。

（3）I2C 是支持多从机的，也就是一个 I2C 控制器下可以挂多个 I2C 从设备，这些不同的 I2C 从设备有不同的器件地址，这样 I2C 主控制器就可以通过 I2C 设备的器件地址访问指定的 I2C。

1、起始位

也就是 I2C 通信起始标志，在  SCL 为高电平的时候，SDA 出现下降沿就表示为起始位，

2、停止位

停止位就是停止 I2C 通信的标志位，在 SCL 位高电平的时候，SDA 出现上升沿就表示为停止位，

3、数据传输

I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上

的数据变化只能在 SCL 低电平期间发生，

4、应答信号

当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。

5、I2C 写时序

主机通过 I2C 总线与从机之间进行通信不外乎两个操作：写和读，I2C 总线单字节写时序

写时序的具体步骤：

1)、开始信号。

2)、发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决

定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位；

3)、 I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作。

4)、从机发送的 ACK 应答信号。

5)、重新发送开始信号。

6)、发送要写写入数据的寄存器地址。

7)、从机发送的 ACK 应答信号。

8)、发送要写入寄存器的数据。

9)、从机发送的 ACK 应答信号。

10)、停止信号。

6、I2C 读时序

单字节读时序

I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值，我们具体来看一下这几步。

1)、主机发送起始信号。

2)、主机发送要读取的 I2C 从设备地址。

3)、读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。

4)、从机发送的 ACK 应答信号。

5)、重新发送 START 信号。

6)、主机发送要读取的寄存器地址。

7)、从机发送的 ACK 应答信号。

8)、重新发送 START 信号。

9)、重新发送要读取的 I2C 从设备地址。

10)、读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。

11)、从机发送的 ACK 应答信号。

12)、从 I2C 器件里面读取到的数据。

13)、主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。

14)、主机发出 STOP 信号，停止 I2C 通信。

I2C 多字节读写时序

有时候我们需要读写多个字节，多字节读写时序和单字节的基本一致，只是在读写数据的

时候可以连续发送多个自己的数据，其他的控制时序都是和单字节一样的。

**问题 3：UART 通信**

1、UART 通信格式

空闲位：数据线在空闲状态的时候为逻辑“1”状态，也就是高电平，表示没有数据线空闲，没有数据传输。

起始位：当要传输数据的时候先传输一个逻辑“0”，也就是将数据线拉低，表示开始数据传输。

数据位：数据位就是实际要传输的数据，数据位数可选择 5~8 位，我们一般都是按照字节传输数据的，一个字节 8 位，因此数据位通常是 8 位的。低位在前，先传输，高位最后传输。

奇偶校验位：这是对数据中“1”的位数进行奇偶校验用的，可以不使用奇偶校验功能。

停止位：数据传输完成标志位，停止位的位数可以选择 1 位、1.5 位或 2 位高电平，一般都选择 1 位停止位。

波特率：波特率就是 UART 数据传输的速率，也就是每秒传输的数据位数，一般选择 9600、19200、115200 等。

2、UART 电平标准

UART 一般的接口电平有  TTL 和 RS-232，一般开发板上都有  TXD 和 RXD  这样的引脚，

这些引脚低电平表示逻辑 0，高电平表示逻辑 1，这个就是 TTL 电平。

RS-232 采用差分线，-3~- 15V 表示逻辑 1，+3~+15V 表示逻辑 0。

USB 转 TTL 模块，TTL 接口部分有 VCC、GND、RXD、TXD、

RTS 和 CTS。RTS 和 CTS 基本用不到，使用的时候通过杜邦线和其他模块的 TTL 接口相连即

**问题 4：SPI 通信协议**

相比 I2C 接 口，SPI 接口的通信速度很快，I2C 最多 400KHz，但是 SPI 可以到达几十 MHz。I2C 是串行通信的一种，只需要两根线就可以完成主机和从机之间的通信，但是 I2C 的速度最高只能到 400KHz，如果对于访问速度要求比价高的话 I2C 就不适合了。本章我们就来学习一下另外一个和 I2C 一样广泛使用的串行通信：SPI 是一种高速、全双工的同步通信总线，SPI 时钟频率相比 I2C 要高很多，最高可以工作在上百 MHz。SPI 以主从方式工作，通常是有一个主设备和一个或多个从设备，一般 SPI 需要 4 根线，但是也可以使用三根线(单向传输)，这四根线如下：

①、CS/SS，这个是片选信号线，用于选择需要进行通信的从设备。I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机设备，直接将相应的从机设备片选信号拉低即可。

②SCK，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟。

③、MOSI/SDO，简称主出从入信号线，这根数据线 只能用于主机向从机发送数据，也就是主机输出，从机输入。

④MISO/SDI，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出。

SPI 通信都是由主机发起的，主机需要提供通信的时钟信号。主机通过 SPI 线连接多个从设备的结构。

SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：

①、CPOL=0，串行时钟空闲状态为低电平。

②、CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。

③、CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。

④、CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。

**问题 5：程序的内存分配**

运行程序的内存分为堆区、栈区、BSS 区、数据区（初始化）、代码区。

1. 栈：系统分配空间：存放临时创建的局部变量，存放函数调用的形参和返回值；

局部变量申请的内存空间超过栈的剩余空间就会存在栈的溢出，例如栈中申请很长的数组和递归调用很多次的函数就有可能出现；

1. 堆：由程序员分配释放，若程序员不释放，结束时由 OS 回收，

如果程序员在使用完申请后的堆内存却没有及时把它释放掉，那么这块内存就丢失了，就存在内存泄漏；内存的分配不是连续的。

1. 通常存放程序运行中动态分配的存储空间；（2）使用 malloc 和 new 在堆中分配内存；

1. BSS 区：通常是指用来存放程序中未初始化的全局变量和静态变量静态分配，在程序开始时通常会被清零。

1. 数据区：通常是指用来存放程序中已初始化的全局变量和静态变量以及字符串常量

1. 代码区：通常是指用来存放程序执行代码的一块内存区域，这部分区域的大小在程序运行前就已经确定。

**问题 6：数据类型占用字节大小**

各个类型在 64 位系统中占字节数

char 1；

short int 2 ；

int 4；

unsigned int 4；

float 4；

double 8；

long 8；

long long 8

unsigned long 8

**问题 7：单片机中断流程**

（1）中断就是：CPU 在正常执行程序的过程中，由于内部/外部事件的触发或程序的预先安排引起 CPU 暂时中断当前正在运行的程序，而转去执行中断服务子程序，待中断服务子程序执行完毕后，CPU 继续执行原来的程序，这一过程称为中断；

（2）中断处理过程

第一步：保护现场，将当前位置的 PC 地址压栈；

第二步：跳转到中断服务程序，执行中断服务程序；

第三步：恢复现场，将栈顶的值回送给 PC;

第四步：跳转到被中断的位置开始执行下一个指令

（3）中断服务函数

相对于正常子函数，中断服务函数有以下需要注意的地方：

1.中断服务函数不能传入参数；

2.中断服务函数不能有返回值；

3.中断服务函数应该做到短小精悍；

4.不要在中断函数中使用 printf 函数，会带来重入和性能问题。

**问题 9：main 函数三个参数**

1.int argc 整型变量

2.char \*argv\[\] 字符指针的数组，通俗一点就是字符串数组，每个元素都是字符串

3.char \*envp\[\] 字符串数组

**问题 10：232、485 与 422**

（1）RS-232、RS422 和 RS-485 均属于 UART 是通用异步收发传输器，仅用两根信号线（Rx 和 Tx）就可以完成通信过程；而由于各自使用的电平有所不同，因此由 UART 转换为 RS-232、RS422 或 RS-485 时，需要经过一个转换芯片 SP3232E、SP3485。

（2）RS-232 一般只使用 RXD、TXD、GND 三条线；首先涉及到了电平的变化，UART 使用的芯片自身输出的电压；然后由 UART 的两条信号线 TX 和 RX 转换为 RX-232 的 TX 和 RX;

传输速率较低，在异步传输时，波特率为 20Kbps。

接口使用一根信号线和一根信号返回线而构成共地的传输形式，这种共地传输容易产生共模干扰，所以抗噪声干扰性弱。

RS-232 接口可以实现点对点的通信方式，但这种方式不能实现联网功能。

于是，为了解决这个问题，一个新的标准 RS-485 产生了。

（3）RS-485 的数据信号采用差分传输方式，它使用一对双绞线；RS-422 的电气性能与 RS-485 完全一样。主要的区别在于：RS-422 有 4 根信号线：两根发送、两根接收。由于 RS-422 的收与发是分开的所以可以同时收和发（全双工），也正因为全双工要求收发要有单独的信道，所以 RS-422 适用于两个站之间通信，星型网、环网，不可用于总线网；

RS-485 只有 2 根信号线，所以只能工作在半双工模式，常用于总线网。

**问题 11：sizeof 与 strlen**

1\. sizeof()【操作数所占空间的字节数大小】是一种 c 中的基本运算符。

可以以类型、指针、数组和函数等作为参数。

返回值类型为 unsigned int

比如 char a\[5\]="123";

int b=sizeof(a);//b=5

int c=strlen(a);//c=3

2.strlen()\[计算字符串的长度\]是一种函数。

'\\0’作为终止符;

其参数必须是字符型指针（char\*）。

头文件为#include<string.h>

**问题 12：什么是回调函数**

1\. 什么是回调函数：

函数指针的调用，即是一个通过函数指针调用的函数；

如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。

即：把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称为异步回调。

2\. 为什么要使用回调函数

回到函数作用：“解耦”，普通函数代替不了回调函数的这个特点。这是回调函数最大的特点。

使用回调函数，和普通函数调用区别：1）在主入口程序中，把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，且不需要修改库函数的实现，变的很灵活，这就是解耦。

2）主函数和回调函数是在同一层的，而库函数在另外一层。如果库函数对我们不可见，我们修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那我们就只能通过传入不同的回调函数了，这也就是在日常工作中常见的情况。

3\. 回调函数：使用其实也是不得已而为之，是一种解决问题的策略

回调函数的使用是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想

回调函数的缺点：

1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。

2）回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。

**问题 13：全局变量和局部变量的区别**

1.作用域不同：全局变量的作用域为整个程序，局部变量的作用域为当前语句块；

2.内存储存方式：全局变量存储在全局数据区，局部变量存储在栈上；

3.生命周期不同：全局变量的生命周期和程序一样，局部变量随着语句块的结束而结束；

4.当局部变量与全局变量同名时，优先使用局部变量;

**问题 14：结构体和联合体的区别**

1.结构体和联合体都是由不同的数据类型组成，但在任何时刻，联合体只存在一个被选中的成员，结构体所有成员都存在。

2.在结构体中，各成员占有自己的储存空间，总大小等于各成员的大小之和

3.在联合体中，所有成员公用一块储存空间，其大小等于联合体中最大成员的大小

**问题 15：指针和数组的区别**

1.数组要么在静态存储区，要么在栈上被创建。数组名对应着一块内存，其容量与地址在生命周期内保持不变。

2.指针可以随时指向任意类型的内存块，他的特征是可变。比数组灵活，但也危险。

**问题 16：指针函数和函数指针的区别**

1.指针函数是一个函数，它的返回值是一个指针。

2.函数指针是一个指针，这个指针指向的对象是一个数组。

**问题 17：常量和变量的区别**

1.常量是只读不可写，变量可读可写常量必须初始化，变量可以不初始化；

2.常量不可以寻址，它的地址不可赋值非常量指针；变量可以寻址，常量的效率比变量高。

**问题 18：指针自增自减与变量自增自减有什么区别？**

指针自增自减是改变指针所指向的对象，变量自增自减是改变变量的值；

**问题 19：#include <stdio.h>与#include "stdio.h"的区别？**

<stdio.h>表示的是该文件存在编译器指定的标准头文件存放处

"stdio.h"表示的是该文件在用户当前的工作目录下

**问题 20：头文件中的 ifdef/define endif 的作用是什么？**

防止头文件被重复引用

**问题 21：用#define 实现宏并求最大值与最小值**

`#define MAX(X,Y) ((X)>(Y)?(X):(Y))`

`#define MIN(X,Y) ((X)<(Y)?(X):(Y))`

**问题 22：break 语句与 continue 语句的区别**

continue 语句只能出现在循环语句内，表示结束本次循环；

break 语句还能出现在 switch 语句中，表示结束 switch 语句，出现在循环语句中，表示结束整个循环。

**问题 23：static 与 const 关键字的区别**

1.static 关键字

(1)static 用于全局变量：表示该变量是静态全局变量，

(2)作用域为当前文件用于函数：该函数为静态函数，只能在本文件中调用；静态函数在内存中只有一份，普通函数在内存中只有一份拷贝；

(3)用于局部变量：为静态局部变量，只初始化一次，之后调用函数都是上次函数退出的值。即改变变量的生存周期为整个程序运行时间段内。

(4)static 成员函数：表示这个函数属于此而不属于此类的任何

(5)static 成员变量：表示该变量属于此类而不属于此类的任何对象，该变量的初始化在此类体外。

2.const 关键字

(1)修饰一般常量：修饰符可在类型说明符前也可以在类型说明符后；

(2)修饰数组：修饰符 const 可以用在类型说明符前，也可以用在类型说明符后；例如：int const a\[5\]={1,2,3};或 const int a\[5\]={1,2,3};

(3)修饰常指针：const int \*A; //const 修饰指针指向的对象，指针可变，指针指向的对象不可变；

举例：int const \*A; //修饰指针指向的对象，指针可变，指针指向的对象不可变； int \*const A;//const 修饰指针，指针不可变，指针指向的对象可变；

**问题 24：const 与宏的区别**

(1)编译检查 宏不会编译检查，const 有编译检查

(2)宏的好处 宏可以定义函数、方法等，const 不可以

(3)宏的缺点 大量使用宏，会导致预编译的时间过长

**问题 25：引用与指针的区别**

(1)非空区别：指针可以指向 NULL，引用必须指向某个对象

(2)可修改区别：指针可以指向不同的对象，引用总是指向初始化的对象

(3)合法性区别：在使用指针之前要判断是否为 NULL，引用不需要判断

**问题 26：malloc()与 calloc()的区别**

(1)malloc 与 calloc 都是从堆上动态申请内存空间。

(2)malloc 只有一个参数，即要分配的内存大小。

(3)calloc 函数有两个参数，分别是元素的个数与元素的大小。

(4)malloc 不能对内存初始化，calloc 堆内存的每一位初始化为零。

**问题 27：strcpy、sprint 和 memcpy 的区别**

（1）strcpy 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝

（2）sprint 函数操作的对象不限于字符串，是实现其他数据类型先给高字符串的转化，方法中需要指定源对象的数据类型，如果源对象是字符串，也可以实现字符串的拷贝功能。

（3）memcpy 函数是内存的拷贝，实现将一个内存的内容复制到另一个内存块。内存块由首地址及长度决定。

（4）strcpy 为什么要返回 char \*类型

增加代码的灵活性，方便其他函数直接调用

**问题 28：多线程问题：目前我没学到这，我直接回答不太了解。**

**问题 29：问一些 linux 常见命令。**

\------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
