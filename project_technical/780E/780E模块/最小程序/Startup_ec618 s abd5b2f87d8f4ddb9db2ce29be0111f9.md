# Startup_ec618.s

启动代码文件名一般为 startup_ec618.s

.s 汇编文件 汇编代码

启动文件是使用机器认识的汇编语言，经过一些必要的配置，最终能够调用 main 函数，使得用户程序能够在 MCU上正常运行起来的必备文件。

### 启动代码的作用

1） 堆和栈的初始化
包括堆栈的大小，MSP（main stack pointer）值等。MSP的初始值在复位阶段取自存储区的第一个字（即0地址处的值）。
栈Stack: 由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。向低地址扩展。
堆Heap: 一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。分配方式类似于数据结构中的链表。向高地址扩展。

2） 向量表定义 
定义了各MSP初值，以及各个中断服务程序（ISR）的入口地址。

3） 中断服务程序 
CPU根据中断号从向量表中获取入口地址后，跳转至对应的ISR。

4） 设置系统时钟频率
可在复位中断服务程序Reset_handler中调用系统时钟频率初始化程序

5） 中断寄存器的初始化

6）进入C应用程序

在复位中断服务程序即Reset_handler中实现进入C程序。

Cortex-M3 内核规定，起始地址必须存放栈顶指针，而第二个地址则必须存放复位中断入口向量地址，这样在 Cortex-M3 内核复位后，会自动从起始地址的下一个 32 位空间取出复位中断入口向量，跳转执行复位中断服务程序。Cortex-M3 内核固定了中断向量表的位置, 但是起始地址是可变化的。

Cortex-M3是32位的单片机，因此其PC指针可以指向2^32=4G的地址空间，也就是图中的 0x00000000到0xFFFFFFFF的区间，也就是将程序存储器、数据存储器、寄存器和输入输出端口被组织在同一个4GB的线性地址空间内，数据字节以小端格式存放在存储器中。

### **C/C++ 程序编译后的存储数据段**

**.data:**数据段;static声明的变量; 全局静态变量和局部静态变量;是在程序运行的时候需要在RAM中运行。

**.BSS:**储存未初始化的，或初始化为0的全局变量和静态变量。放在RAM里。

**.text:**代码段，储存程序代码;放在Flash里。

**.constdata:**储存只读常量**;**放在Flash 里。所以为了节省 RAM，把常量的字符串，数据等 用const声明

**heap（堆）:**存放进程运行中被动态分配的内存段。他的大小并不固定;放在RAM里

**stack（栈）:**用户存放程序临时创建的局部变量，由系统自动分配和释放;在函数被调用时，其参数也会被压入发起调用的进程栈中,并且待到调用结束后，函数的返回值也会被存放回栈中。放在RAM里

### **程序编译后的内存占用情况**

MDK编译与GCC编译的区别：

两者都是编译器，可以将源代码编译成可执行文件。

MDK-ARM 是由 ARM 公司提供的一种编译器，它支持 ARM 架构的微控制器。GCC 是一个开源的编译器，它支持多种架构和操作系统。

两者之间的主要区别在于它们所支持的平台和功能。MDK-ARM 主要用于开发 ARM 架构的微控制器，它提供了紧凑且稳定的集成开发环境，包括 C/C++ 编译器、调试器和 JTAG/SWD 接口。GCC 则是一个通用的编译器，它支持多种架构和操作系统，但使用起来可能需要更多的配置工作

模块使用GCC编译

FLASH=text+data

RAM=data+bss

startup_ec618.s文件是系统的启动文件，主要完成三个工作：栈和堆的初始化、定位中断向量表、调用Reset Handler。在其中可以看到定义的堆和栈定义的大小。

.map文件中可以看到HEAP和Stack的起始地址。

注意的是：

堆使用时候从起始地址开始，往上加

栈使用时候从结束地址，就是__initial_sp（栈顶指针的地址）开始，往下减

cpu在运行时，单片机等嵌入式系统是存储在flash中。

单片机的程序则是固化在flash中，cpu运行时直接从flash中读取程序，从RAM中读取数据

单片机的构架大多是哈弗体系的，即程序和数据分开存储，而且单片的片内RAM资源是相当有限的，内部的RAM过大会带来成本的大幅度提高。（哈佛总线体系机构的芯片内部程序空间和数据空间是分开的，允许同时取指令和取操作数，运算能力提升）

### 查看内存分配

MDK环境中，查看栈和堆的大小是在.s文件中的声明

```bash
Stack_Size EQU 0x00000800 
 Heap_Size EQU 0x00000c00
```

GCC环境中，查看堆栈大小是在LD文件中

```bash
_Min*_*Heap_Size=0x200;
_Min_Stack_Size=0x400;
```

GCC和MDK编译生成的map文件不同。

### 模块三种启动方式

- 从闪存存储器启动
    
    最常用的用户FLASH启动；从闪存存储器启动：主闪存存储器被映射到启动空间(0x0000 0000) ,也就是0x08000000被映射到0x00000000。
    
- 从系统存储器启动
    
    串口下载方式（ISP）；系统存储器被映射到启动空间(0x0000 0000)，也就是0x1FFF F000被映射到0x00000000。
    
- 从内嵌SRAM启动
    
    该模式用于调试。 用jlink在线仿真，则是下载到SRAM中。SRAM起始地址 0x2000 0000 被映射到0x00000000。
    

### 启动文件分析

- MDK环境

这个就是startup_ec618.s中的格式就符合MDK环境的文件。

- GCC环境

gcc环境中除了需要.s文件还需要一个链接文件

链接文件主要制定了入口函数，堆栈到校和数据段的整体布局。

在luatos-soc-2022中找到ec618_0h00_flash.ld 。找到.load_dram_bsp中*libstartup*:system_ec618.0(.data*)

然后找到了system_ec618.h文件。

CMSIS设备系统头文件用于ARMCM3设备系列

system_ec618.h中定义了一些SystemInit、SystemCoreClockUpdate、SaveAndSetIRQMask、RestoreIRQMask（IRQ：中断请求）